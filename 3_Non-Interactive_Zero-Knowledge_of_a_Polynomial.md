# Non-Interactive Zero-Knowledge of a Polynomial

<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=4 orderedList=false} -->

<!-- code_chunk_output -->

- [example3:prover claims to know a degree 3 polynomial with two roots](#example3prover-claims-to-know-a-degree-3-polynomial-with-two-roots)
- [Obscure Evaluation](#obscure-evaluation)
  - [Homomorphic Encryption](#homomorphic-encryption)
  - [Modular Arithmetic](#modular-arithmetic)
  - [Strong Homomorphic Encryption](#strong-homomorphic-encryption)
  - [Encrypted Polynomial](#encrypted-polynomial)
- [Restricting a Polynomial](#restricting-a-polynomial)

<!-- /code_chunk_output -->


到目前为止，讨论集中在证据的弱概念上，即各方必须相互信任，还没有任何措施来强制协议的规则。例如，证明者不需要知道多项式，他可以使用任何手段设法通过验证。此外，如果验证者的多项式取值范围不足够大，那证明者可能会存在一个不可忽视的概率猜测到x。我们需要解决这个协议的弱点，首先要知道多项式意味着什么？一个多项式可以以下面的形式表示（n代表多项式的次数）：

$$
c_nx^n+...+c_1x^1+c_0x^0
$$

如果一个人说他知道一个一次多项式，那就代表他知道$c_0,c_1$,此外，系数可以是任何值，包括0。

## example3:prover claims to know a degree 3 polynomial with two roots

> 假设证明者知道一个3次多项式，使得x=1,x=2是所有可能解的两个。比如$x^3-3x^2+2x=0$

代数基本定理指出，任何多项式都可以分解成线性多项式（一次多项式），只要它是可解的。因此，我们可以将任何有效的多项式表示为其因子的乘积：

$$
(x-a_0)(x-a_1)...(x-a_n)=0
$$

任意一个因子是0则整个等式等于0，因此，$a_i,i=1,2,...n$是方程的解。我们的例子就可以分解为下面的多项式：

$$
x^3-3x^2+2x=(x-0)(x-1)(x-2)
$$

方程的解（x的值）：0，1，2。回到证明者声称他知道一个根为1，2的三次多项式，这意味着他的多项式具有以下形式：

$$
(x-1)(x-2)\cdot...
$$

换句话说，(x-1),(x-2)是所讨论多项式的“余因子”。因此，如果证明者想要证明他的多项式拥有这些根而不暴露原本的多项式，他需要证明他的多项式$p(x)$,是余因式$t(x)=(x-1)(x-2)$,这里称为目标多项式，与一些任意的多项式$h(x)$的乘积（在我们的例子里是x-0）：

$$
p(x)=t(x)\cdot h(x)
$$

换句话说，存在 $ h(x) $使得上面的式子成立，那么 $ p(x) $包含 $ t(x) $,所以 $ p(x) $包含 $ t(x) $的所有根，这就是要证明的。
一个自然的方法就是通过除法找 $ h(x) $, $h(x)=\frac{p(x)}{t(x)}$。如果证明者不能找到这样的 $ h(x) $意味着 $ p(x) $没有余因子 $ t(x) $,在这种情况下，多项式除法会有余数。
在我们的例子中：
$$
h(x)=\frac{p(x)}{t(x)}=\frac{x^3-3x^2+2x}{x^2-3x+2}=x
$$

Note:为了简单起见，我们将使用多项式的字母变量来表示它的值，比如 $ p=p(r) $

使用我们的多项式恒等检查协议，我们可以比较多项式 $ p(x)\;and\;t(x)\cdot h(x) $:
- Verifier 采样一个随机数r，计算$t=t(r)$,将r发送给Prover
- Prover计算 $h(x)=\frac{p(x)}{t(x)}$,然后计算$ p(r)\;and\; h(r) $，并将结果p，h发送给Verifier
- Verifier checks $ p = t\cdot h $，如果多项式相等，则 $ p(x) $ 有余因子 $ t(x) $

实例：

$$
p(x)=x^3-3x^2+2x\\t(x)=(x-1)(x-2)
$$
- Verifier samples a random value 23,t = t(23) = 462 and gives 23 to the prover
- Prover calculates h(x) = x, evaluates p = p(23)=10626 and h = h(23)=23 and provides p,h to the verifier
- checks $ p = t\cdot h:10626=462\cdot 23 $ which is true, and therefore the statement is proven

相反的，若果证明者用一个不同的 $ p'(x) $,不包含必要的余因子，例如 $ p'(x)=2x^3-3x^2+2x $。我们会得到 $ h(x)=2x+3+7x-6;\;\;p(x)=t(x)\cdot(2x+3)+7x-6 $。这意味着证明者必须将余数除以 $ t(r) $以计算 $ h(x)=2x+3+\frac{7x-6}{t(x)} $。由于验证者对x的随机选择，余数7x-6被t(x)整除的概率很低。验证者可以另外检查p和h，要求必须是整数，则上述的证明会被拒绝。然而，这样的校验要求多项式系数也是整数，这对协议产生了显著的限制。

这就是引入加密原语的原因，这些原语使得这种除法不可能，即使原始计算是碰巧可除的。

现在我们可以检查多项式的特定属性，而无须学习多项式本身，因此这已经为我们提供了某种形式的零知识和简洁性。尽管如此，这种构造存在多个问题：

* 验证者可能完全不知道声明的多项式 $ p(x) $,他可以计算 $ t=t(r) $,选择一个随机数h并且令 $ p=t\cdot h $,等式依然会成立，该陈述会被接受为有效。
* 证明者知道随机点 $ x=r $,所以他可以构造任何在r处有一个公共点的多项式 $ t(r)\cdot h(r)$
* 在最初的陈述中，Prover声称知道一个特定次数的多项式，在目前的协议中，不存在次数的限制。因此，证明者可以通过使用更高次的多项式来欺骗，该多项式也满足余因子检查

## Obscure Evaluation

上述的前两个问题是很可能的，因为值是以原始值表示的，`证明者`知道 $ r,t(r) $。如果这些值是以黑盒的方式给出的，那将会是理想的，这样`证明者`就无法修改协议，但仍然在这些模糊值上计算。有一点类似与哈希函数，在计算时很难获得原始输入。

### Homomorphic Encryption

这正是同态加密的设计目的。同态加密可以加密原始值，并且能够对加密值应用算术运算。

通常的想法是，我们选择一个基本自然数`g`比如`5`，为了加密一个值，我们将g取该值的幂。例如，如果我们想加密这个数字：

$$
5^3=125
$$

值125是3的加密。如果我们想到把加密的数字乘以2，我们将它提升到指数：

$$
125^2=15625={(5^{3})}^2=5^{2\times 3}=5^6
$$

也可以通过乘法将两个加密值相加，例如3+2：

$$
5^3\cdot 5^2=5^{3+2}=5^5=3125
$$

类似的，用除法减去加密的数字:

$$
\frac{5^5}{5^3}=5^5\cdot 5^{-3}=5^{5-3}=5^2=25
$$

然而，由于基数5是公开的，所以很容易获得秘密数字：除以加密的5，知道结果为1。步数是秘密数字。

### Modular Arithmetic

如果没有模运算，运算的结果直接暴露了密文。而通过模运算，秘文的信息将被隐藏，而公共的算术属性将被保留。

模运算是指在求解余数的过程中，将一个数除以另一个数并得到余数的运算。在密码学中，模运算通常用于对加密后的数据进行压缩和处理，以使其符合指定的范围，并将其转换为更易于处理的形式。例如，在Diffie-Hellman密钥交换算法中，模运算用于计算共享密钥。在RSA加密算法中，模运算用于加密和解密过程中的指数运算。

### Strong Homomorphic Encryption

如果我们回到同态加密并使用模运算，例如`mod 7`,我们会得到:

$$
5^1=5\;(mod\;7)\\
5^2=4\;(mod\;7)\\
5^3=6\;(mod\;7)\\
...
$$

不同的指数可能会有相同的结果：

$$
5^5=3\;(mod\;7)\\
5^{11}=3\;(mod\;7)\\
5^{17}=3\;(mod\;7)\\
...
$$

通过模运算使得找到指数变得非常困难。事实上，如果模足够大，那么这样做就变得不可行，并且现代密码学的很大一部分是基于这个问题的“难度”。

该方案的所有同态性质都保留在模域中：

$$
\begin{aligned}
&&encryption:&& 5^3=6\;\;(mod \;7)\\
&&multiplication:&& \;\;\;\;6^2={(5^3)}^2=5^6=1\;\;(mod\;7)\\
&&addition:&& 5^3\cdot 5^2=5^5=3\;\;(mod\;7)
\end{aligned}
$$

我们明确的声明加密函数：$ E(v)=g^v\;\;(mod\;n) $，$ v $是我们想要加密的值。

### Encrypted Polynomial

有了这样的工具，我们现在可以用加密的随机值x来计算多项式，并相应地修改零知识协议。

让我们看看如何计算多项式：$ p(x)=x^3-3x^2+2x $，要知道多项式就是要知道它的系数，在这种情况下，这些系数是：$ 1，-3，2 $。因为同态加密不允许对加密值取幂，所以我们必须给出从1到3的x的幂的加密值：$ E(x),E(x^2),E(x^3) $，因此我们可以如下计算加密的多项式：

$$
\begin{aligned}
{E(x)}^1\cdot {E(x^2)}^{-3}\cdot {E(x^3)}^2=\\
{(g^{x^3})}^1\cdot {(g^{x^2})}^{-3}\cdot {(g^x)}^1=\\
g^{{1x}^3}\cdot g^{-3x^2}\cdot g^{2x}=\\
g^{x^3-3x^2+2x}\;\;\;\;
\end{aligned}
$$

在这样的计算之后，我们可以加密多项式在未知x处的取值。这是一个十分强大的机制，并且因为同态的性质，同一个多项式的加密求值在加密空间中总是相同的。

我们更新之前的协议版本，得到一个d次多项式：

* Verifier
    - 采样一个随机数s 即secret
    - 计算s的所有幂次的取值 $ for\;all\;powers\;i\;in\;0,1,...,d\;i.e.:\;E(s^i)=g^{s^i}$
    - 用s计算未加密的目标多项式：$ t(s) $
    - 将加密后的s的幂发送给`证明者`：$ E(s^0),E(s^1),...,E(s^d) $
* Prover
    - 计算多项式 $ h(x)=\frac{p(x)}{t(x)} $
    - 使用加密的幂 $ g^{s^0},g^{s^1},...,g^{s^d} $与系数 $ c_0,c_1,...,c_n $计算
    $$
    \begin{aligned}
    E(p(s))&=g^{p(s)}\\
    &={(g^{s^d})}^{c_d} \cdot\cdot\cdot {(g^{s^1})}^{c_1}\cdot {(g^{s^0})}^{c_0}\\
    &=g^{c_d\cdot s^d + \cdot \cdot \cdot c_1\cdot s^1 + c_0\cdot s^0}
    \end{aligned}
    $$
    类似的计算 $ E(h(s))=g^{h(s)} $
    - 将计算结果 $ g^p,g^h $提供给`验证者`
* Verifier
    - 验证者在加密空间内检查 $ p=t(s)\cdot h $
    $$
    g^p={(g^h)}^{t(s)}\Rightarrow g^p=g^{t(s)\cdot h}
    $$

通过同态加密，我们将x=r这一步隐藏了起来，变为一个秘密值s，这样`证明者`无法任意的构造一个在s处有公共点的多项式，这样解决了上述方案的缺陷二。但是他仍然可以使用任意的方法来伪造一个证明，而无需实际使用所提供的s的幂的加密。
* ~~验证者可能完全不知道声明的多项式 $ p(x) $,他可以计算 $ t=t(r) $,选择一个随机数h并且令 $ p=t\cdot h $,等式依然会成立，该陈述会被接受为有效。~~
* ~~证明者知道随机点 $ x=r $,所以他可以构造任何在r处有一个公共点的多项式 $ t(r)\cdot h(r)$~~
* 在最初的陈述中，Prover声称知道一个特定次数的多项式，在目前的协议中，不存在次数的限制。因此，证明者可以通过使用更高次的多项式来欺骗，该多项式也满足余因子检查

## Restricting a Polynomial

多项式的定义就是系数的定义 $ c_0,c_1,...,c_i $。协议中，我们分配这些系数的方式是通过对秘密值s对应的加密幂求幂，例如：

$$
E{(s^i)}^{c_i}=g^{c_i\cdot s^i}
$$

我们已经在选择s的加密幂时限制了证明者，但是这种限制并没有被强制执行。某人可以通过任意的手段找到一些任意值 $ z_p,z_h $使得下列等式满足：

$$
z_p={(z_h)}^{t(s)}
$$

将这两个值发过去代替 $ g^p,g^h $。
例如，对一些随机数r，$ z_h=g^r $并且 $ z_p={(g^{t(s)})}^r $，$ g^{t(s)} $可以由s的加密幂计算得到：

$$
\begin{aligned}
假设\;\;\;\;\;\;\;&t(x)=(x-1)(x-2)=x^2-3x+2\\
\Rightarrow &t(s)=s^2-3s+2 \\
\Rightarrow &g^{t(s)}=E(s^2)-{E(s_1)}^3+{E(s^0)}^2\\
\Rightarrow &g^{t(s)}=g^{s^2-3x+2}
\end{aligned}
$$

这就是为什么验证者需要证明只使用提供的s的加密幂来计算 $ g^p,g^h $而不是其他的。

* Alice有一个数值a，她希望Bob对它取任意幂，唯一的要求是只有这个a可以取幂，为了确保这点她：
    - 选择一个随机数$\alpha$
    - 计算 $ a' = a^{\alpha}\;(mod\;n)$
    - 将这个元组 $(a,a')$发送给Bob并要求他对每个值执行相同的幂运算并返回指数$"\alpha-shift"$不变的结果元组$(b,b')$ 。例如 $b^{\alpha}\;=b'\;(mod\;n)$
* 因为Bob无法从元组$(a,a')$中提取出$\alpha$(或者使用暴力求解，不可行的)，推测Bob可以产生有效响应的唯一方法是通过以下过程：
    - 选择某个值c
    - 计算$b = (a)^c\;(mod\; n)$与$b'=(a')^c\;(mod\;n)$
    - 回复$(b,b')$
* 有了响应和$\alpha$，Alice检查等式：
    - $$
    (b)^{\alpha}=b'\\
    (a^c)^{\alpha}=(a')^c\\
    a^{c\cdot \alpha}=(a^{\alpha})^c
    $$
* 结论：
    - Bob在元组的两个值上使用了相同的指数（即，c），不使用无法通过最后一步的check
    - Bob仅能使用原始的Alice的元组来维护$\alpha$关系
    - Bob知道应用的指数c，因为只有相同的指数才能够生成有效的元组$(b,b')$
    - Alice无法知道c如同Bob无法知道$\alpha$

最终，这样的协议向Alice提供了Bob确实通过他已知的某个值对a取幂的证明，并且他不能进行任何其他操作，例如，乘法、加法，这会消除$\alpha-shift$关系

在同态加密上下文中，取幂是加密值的乘法，我们可以在简单的单系数多项式的情况下应用相同的构造，$f(x)=c\cdot x$：

* 验证者选择随机数$s,\alpha$并提供$x=s$的幂1和它的“shift”：$(g^s,g^{\alpha \cdot s})$
* 证明者应用系数c：$((g^s)^c,(g^{\alpha \cdot s})^c)$
* 验证者检查：$(g^{c\cdot s})^{\alpha} = g^{\alpha \cdot c \cdot s}$

这一的构造限制证明者仅使用所提供的加密的s，因子证明者可以仅将系数c分配给有验证者提供的多项式。我们现在可以将这一种多项式方法拓展到多项多项式，因为每个项的系数分配是单独计算的，然后同态“相加”在一起。所以，如果证明者被基于s的加密幂以及它们的移位值，他就可以计算原始的和移位的多项式，同样的检验必须成立。特别地，对于d次多项式：

* 验证者提供加密幂$g^{s^0},g^{s^1},...,g^{s^d}$和他们的移位$g^{\alpha s^0},g^{\alpha s^1},...,g^{\alpha s^d}$
* 证明者：
    - 用提供的s计算加密多项式：
    $$
    g^{p(s)}=(g^{s^0})^{c_0}\cdot (g^{s^1})^{c_1}\cdot ... \cdot (g^{s^d})^{c_d}=g^{c_0s^0+c_1s^1+...+c_ds^d}
    $$
    - 用相应的s的幂的$\alpha-shift$计算加密的“移位”多项式
    $$
    g^{\alpha p(s)}=
    (g^{\alpha s^0})^{c_0}\cdot
    (g^{\alpha s^1})^{c_1}\cdot ... \cdot
    (g^{\alpha s^d})^{c_d}
    =g^{c_0\alpha s^0+c_1 \alpha s^1+...+c_d\alpha s^d}
    =g^{\alpha(c_0s^0+c_1s^1+...+c_ds^d)}
    $$
    - 将$g^P,g^{P'}$发送给验证者
    - 验证者检查:$(g^P)^{\alpha}=g^{P'}$

对于我们前面的多项式$p(x)=x^3-3x^2+2x$是：
    - 验证者提供$origin:E(s^3),E(s^2),E(s),shift:E(\alpha s^3),E(\alpha s^2),E(\alpha s)$
    - 证明者计算：
    $$
    g^P=g^{p(s)}
    =(g^{s^3})^1\cdot(g^{s^2})^{-3}\cdot(g^s)^2
    =g^{s^3}\cdot g^{-3s^2}\cdot g^{2s}
    =g^{s^3-3s^2+2s}\\
    g^{P'}=g^{\alpha p(s)}
    =(g^{\alpha s^3})^1\cdot
    (g^{\alpha s^2})^{-3}\cdot
    (g^{\alpha s^1})^2
    =g^{\alpha s^3}\cdot
    g^{-3\alpha  s^2}\cdot
    g^{2\alpha s}
    =g^{\alpha(s^3-3s^2+2s)}
    $$
    - 验证者检查：
    $$
    (g^{s^3-3s^2+2s})^{\alpha}=g^{\alpha(s^3-3s^2+2s)}\\
    g^{\alpha(s^3-3s^2+2s)}=g^{\alpha(s^3-3s^2+2s)}
    $$