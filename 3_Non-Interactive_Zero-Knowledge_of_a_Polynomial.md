# Non-Interactive Zero-Knowledge of a Polynomial

<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=4 orderedList=false} -->

<!-- code_chunk_output -->

- [example3:prover claims to know a degree 3 polynomial with two roots](#example3prover-claims-to-know-a-degree-3-polynomial-with-two-roots)
- [Obscure Evaluation](#obscure-evaluation)
  - [Homomorphic Encryption](#homomorphic-encryption)
  - [Modular Arithmetic](#modular-arithmetic)
  - [Strong Homomorphic Encryption](#strong-homomorphic-encryption)
  - [Encrypted Polynomial](#encrypted-polynomial)

<!-- /code_chunk_output -->


到目前为止，讨论集中在证据的弱概念上，即各方必须相互信任，还没有任何措施来强制协议的规则。例如，证明者不需要知道多项式，他可以使用任何手段设法通过验证。此外，如果验证者的多项式取值范围不足够大，那证明者可能会存在一个不可忽视的概率猜测到x。我们需要解决这个协议的弱点，首先要知道多项式意味着什么？一个多项式可以以下面的形式表示（n代表多项式的次数）：

$$
c_nx^n+...+c_1x^1+c_0x^0
$$

如果一个人说他知道一个一次多项式，那就代表他知道$c_0,c_1$,此外，系数可以是任何值，包括0。

## example3:prover claims to know a degree 3 polynomial with two roots

> 假设证明者知道一个3次多项式，使得x=1,x=2是所有可能解的两个。比如$x^3-3x^2+2x=0$

代数基本定理指出，任何多项式都可以分解成线性多项式（一次多项式），只要它是可解的。因此，我们可以将任何有效的多项式表示为其因子的乘积：

$$
(x-a_0)(x-a_1)...(x-a_n)=0
$$

任意一个因子是0则整个等式等于0，因此，$a_i,i=1,2,...n$是方程的解。我们的例子就可以分解为下面的多项式：

$$
x^3-3x^2+2x=(x-0)(x-1)(x-2)
$$

方程的解（x的值）：0，1，2。回到证明者声称他知道一个根为1，2的三次多项式，这意味着他的多项式具有以下形式：

$$
(x-1)(x-2)\cdot...
$$

换句话说，(x-1),(x-2)是所讨论多项式的“余因子”。因此，如果证明者想要证明他的多项式拥有这些根而不暴露原本的多项式，他需要证明他的多项式$p(x)$,是余因式$t(x)=(x-1)(x-2)$,这里称为目标多项式，与一些任意的多项式$h(x)$的乘积（在我们的例子里是x-0）：

$$
p(x)=t(x)\cdot h(x)
$$

换句话说，存在 $ h(x) $使得上面的式子成立，那么 $ p(x) $包含 $ t(x) $,所以 $ p(x) $包含 $ t(x) $的所有根，这就是要证明的。
一个自然的方法就是通过除法找 $ h(x) $, $h(x)=\frac{p(x)}{t(x)}$。如果证明者不能找到这样的 $ h(x) $意味着 $ p(x) $没有余因子 $ t(x) $,在这种情况下，多项式除法会有余数。
在我们的例子中：
$$
h(x)=\frac{p(x)}{t(x)}=\frac{x^3-3x^2+2x}{x^2-3x+2}=x
$$

Note:为了简单起见，我们将使用多项式的字母变量来表示它的值，比如 $ p=p(r) $

使用我们的多项式恒等检查协议，我们可以比较多项式 $ p(x)\;and\;t(x)\cdot h(x) $:
- Verifier 采样一个随机数r，计算$t=t(r)$,将r发送给Prover
- Prover计算 $h(x)=\frac{p(x)}{t(x)}$,然后计算$ p(r)\;and\; h(r) $，并将结果p，h发送给Verifier
- Verifier checks $ p = t\cdot h $，如果多项式相等，则 $ p(x) $ 有余因子 $ t(x) $

实例：

$$
p(x)=x^3-3x^2+2x\\t(x)=(x-1)(x-2)
$$
- Verifier samples a random value 23,t = t(23) = 462 and gives 23 to the prover
- Prover calculates h(x) = x, evaluates p = p(23)=10626 and h = h(23)=23 and provides p,h to the verifier
- checks $ p = t\cdot h:10626=462\cdot 23 $ which is true, and therefore the statement is proven

相反的，若果证明者用一个不同的 $ p'(x) $,不包含必要的余因子，例如 $ p'(x)=2x^3-3x^2+2x $。我们会得到 $ h(x)=2x+3+7x-6;\;\;p(x)=t(x)\cdot(2x+3)+7x-6 $。这意味着证明者必须将余数除以 $ t(r) $以计算 $ h(x)=2x+3+\frac{7x-6}{t(x)} $。由于验证者对x的随机选择，余数7x-6被t(x)整除的概率很低。验证者可以另外检查p和h，要求必须是整数，则上述的证明会被拒绝。然而，这样的校验要求多项式系数也是整数，这对协议产生了显著的限制。

这就是引入加密原语的原因，这些原语使得这种除法不可能，即使原始计算是碰巧可除的。

现在我们可以检查多项式的特定属性，而无须学习多项式本身，因此这已经为我们提供了某种形式的零知识和简洁性。尽管如此，这种构造存在多个问题：

* 验证者可能完全不知道声明的多项式 $ p(x) $,他可以计算 $ t=t(r) $,选择一个随机数h并且令 $ p=t\cdot h $,等式依然会成立，该陈述会被接受为有效。
* 证明者知道随机点 $ x=r $,所以他可以构造任何在r处有一个公共点的多项式 $ t(r)\cdot h(r)$
* 在最初的陈述中，Prover声称知道一个特定次数的多项式，在目前的协议中，不存在次数的限制。因此，证明者可以通过使用更高次的多项式来欺骗，该多项式也满足余因子检查

## Obscure Evaluation

上述的前两个问题是很可能的，因为值是以原始值表示的，`证明者`知道 $ r,t(r) $。如果这些值是以黑盒的方式给出的，那将会是理想的，这样`证明者`就无法修改协议，但仍然在这些模糊值上计算。有一点类似与哈希函数，在计算时很难获得原始输入。

### Homomorphic Encryption

这正是同态加密的设计目的。同态加密可以加密原始值，并且能够对加密值应用算术运算。

通常的想法是，我们选择一个基本自然数`g`比如`5`，为了加密一个值，我们将g取该值的幂。例如，如果我们想加密这个数字：

$$
5^3=125
$$

值125是3的加密。如果我们想到把加密的数字乘以2，我们将它提升到指数：

$$
125^2=15625={(5^{3})}^2=5^{2\times 3}=5^6
$$

也可以通过乘法将两个加密值相加，例如3+2：

$$
5^3\cdot 5^2=5^{3+2}=5^5=3125
$$

类似的，用除法减去加密的数字:

$$
\frac{5^5}{5^3}=5^5\cdot 5^{-3}=5^{5-3}=5^2=25
$$

然而，由于基数5是公开的，所以很容易获得秘密数字：除以加密的5，知道结果为1。步数是秘密数字。

### Modular Arithmetic

如果没有模运算，运算的结果直接暴露了密文。而通过模运算，秘文的信息将被隐藏，而公共的算术属性将被保留。

模运算是指在求解余数的过程中，将一个数除以另一个数并得到余数的运算。在密码学中，模运算通常用于对加密后的数据进行压缩和处理，以使其符合指定的范围，并将其转换为更易于处理的形式。例如，在Diffie-Hellman密钥交换算法中，模运算用于计算共享密钥。在RSA加密算法中，模运算用于加密和解密过程中的指数运算。

### Strong Homomorphic Encryption

如果我们回到同态加密并使用模运算，例如`mod 7`,我们会得到:

$$
5^1=5\;(mod\;7)\\
5^2=4\;(mod\;7)\\
5^3=6\;(mod\;7)\\
...
$$

不同的指数可能会有相同的结果：

$$
5^5=3\;(mod\;7)\\
5^{11}=3\;(mod\;7)\\
5^{17}=3\;(mod\;7)\\
...
$$

通过模运算使得找到指数变得非常困难。事实上，如果模足够大，那么这样做就变得不可行，并且现代密码学的很大一部分是基于这个问题的“难度”。

该方案的所有同态性质都保留在模域中：

$$
\begin{aligned}
&&encryption:&& 5^3=6\;\;(mod \;7)\\
&&multiplication:&& \;\;\;\;6^2={(5^3)}^2=5^6=1\;\;(mod\;7)\\
&&addition:&& 5^3\cdot 5^2=5^5=3\;\;(mod\;7)
\end{aligned}
$$

我们明确的声明加密函数：$ E(v)=g^v\;\;(mod\;n) $，$ v $是我们想要加密的值。

### Encrypted Polynomial

有了这样的工具，我们现在可以用加密的随机值x来计算多项式，并相应地修改零知识协议。

让我们看看如何计算多项式：$ p(x)=x^3-3x^2+2x $，要知道多项式就是要知道它的系数，在这种情况下，这些系数是：$ 1，-3，2 $。因为同态加密不允许对加密值取幂，所以我们必须给出从1到3的x的幂的加密值：$ E(x),E(x^2),E(x^3) $，因此我们可以如下计算加密的多项式：

$$
\begin{aligned}
{E(x)}^1\cdot {E(x^2)}^{-3}\cdot {E(x^3)}^2=\\
{(g^{x^3})}^1\cdot {(g^{x^2})}^{-3}\cdot {(g^x)}^1=\\
g^{{1x}^3}\cdot g^{-3x^2}\cdot g^{2x}=\\
g^{x^3-3x^2+2x}\;\;\;\;
\end{aligned}
$$

在这样的计算之后，我们可以加密多项式在未知x处的取值。这是一个十分强大的机制，并且因为同态的性质，同一个多项式的加密求值在加密空间中总是相同的。

我们更新之前的协议版本，得到一个d次多项式：

* Verifier
    - 采样一个随机数s 即secret
    - 计算s的所有幂次的取值 $ for\;all\;powers\;i\;in\;0,1,...,d\;i.e.:\;E(s^i)=g^{s^i}$
    - 用s计算未加密的目标多项式：$ t(s) $
    - 将加密后的s的幂发送给`证明者`：$ E(s^0),E(s^1),...,E(s^d) $
* Prover
    - 计算多项式 $ h(x)=\frac{p(x)}{t(x)} $
    - 